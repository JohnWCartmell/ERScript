
## 07 May 2025
flex diagramming --- overhaul and document ER2flex rules and patch some weaknesses.
### Discussion
Current rules can be generalised somewhat around the idea of routes having source exit containers and destination entry containers
and can be extended slightly. 

#### Meta Relationships
All existing rules will change and one new rule will be added. In the new rules, meta-relationships used by the old rules will
be replaced with the following meta-relationships:

##### exitContainer
```
exitContainer : route -> enclosure?
``` 
From a route, the largest enclosure which contains the source but does not contain the destination. This will be undefined for some recursive relationships. Call this the exit container because we can think of the route exiting this container on its way from the source.
Assume for the moment that this is precalculated.
We could calculate it alongside of source/abstract as source/exitContainer.

In the context of a route/source we need the following xpath to calculate
```
let $source := //enclosure[id = current()/id],
    $dest   := //enclosure[id = current()/../destination/id]
   return $source/ancestor-or-self::enclosure
                     [not(./descendant::enclosure = $dest)
                       and 
                       not(./self::enclosure  = $dest)
                     ][1]/id
```
Use this expression in the precalculation of source/exitContainer.
##### entryContainer
```
entryContainer : route -> enclosure?
```
From a route, the largest enclosure which contains the destination but does not contain the source. This will be undefined for some recursive relationships. Call this the entry container because we can think of the route entering this container.
Assume for the moment that this is precalculated.
We could calculate it alongside of destination/abstract as destination/exitContainer.
##### EnteringTopdownRoute
```
EnteringTopdownRoute : enclosure -> route* 
```
From an enclosure,  routes for which this enclosure is an entry container.  Implement by 
```
   <xsl:key name="EnteringTopdownRoute"  match="route[top_down]" use="destination/entryContainer"/>
```
##### ExitingTopdownRoute
From an enclosure, routes which have this as the exit container.
Implement by

```
<xsl:key name="ExitingTopdownRoute" match="route[top_down]" use="source/exitContainer"/>
```
##### ExitContainersOfEnteringTopdownRoutes
```
ExitContainersOfEnteringTopdownRoutes : enclosure -> enclosure*
```
From an enclosure, enclosures that entering top down routes exit from. 
In otherwords,
```
ExitContainersOfEnteringTopdownRoutes
        ::= EnteringTopDownRoute/ExitContainer
```
Implement by
```
   <xsl:key name="ExitContainersOfEnteringTopdownRoutes"
            match="enclosure"
            use="key('ExitingTopdownRoute',id)/destination/entryContainer"/> 
```
##### ActualIncomingTopdownRoute
```
ActualIncomingTopdownRoute : enclosure -> route* 
```
From an enclosure, those top down routes which have this enclosure as their destination. Implement by
```
    <xsl:key name="ActualIncomingTopdownRoute" match="route[top_down]" use="destination/id"/>
```
##### TerminatingNonLocalIncomingTopdownRoute
```
TerminatingNonLocalIncomingTopdownRoute: enclosure -> route* 
```
From an enclosure, those top down routes which have this enclosure as a destination and which have a source that is neither this destination nor is enclosed in the
parent enclosure of the destination.
Implement by
```
<xsl:key name="TerminatingNonLocalIncomingTopdownRoute" 
       match="route[top_down]
                  [let $destination := key('Enclosure',destination/id),
                       $source := key('Enclosure',source/id)
                   return  $destination treat as element(enclosure)
                              and $source treat  as element(enclosure)
                              and not($source/ancestor-or-self::enclosure = $destination/parent::enclosure)
                  ] 
                  "
                  use="destination/id"/>
```


### Summary of Rules

#### Rule x1 (pass two)
Applies to any enclosure which has a preceeding enclosure
and which is neither the entry container of a top down route 
nor has a top down route arriving at it.
For these enclosures 
```
<x> 
   <at>
      <left/>
      <predecessor/>
   </at>
</x>
```
In the absense of rules for y will be generated by smarts as
```
<y>
   <place><top/></place>
   <at><bottom/><predecessor/></at>
</y>
```
Big weakness here if predecessor has an outgoing topdown route!!

#### Rule y1 (pass two)
Applies to enclosures which are entryContainers for topdown routes.
For these enclosures, 
```
<y>
   <place><top/></place>
   <at><bottom/><of>exitContainerOfFirstCompositionalParent</of></at>
</y>
```
TBD Might add something about compositional depth in specifying
exitContainerOfFirstCompositionalParent DBT

#### Rules 3A,B,C (pass three)
Apply to any nested enclosure to which rule y1 does nor apply and which is the destination of at least one
top down route whose source is outside of the parent enclosure within
which the enclosure is nested.

##### Rule 3A
Applies if the enclosure is the first enclosure within its parent enclosure and is preceded by a label. For these enclosures, place left of the parent enclosure
underneath the label as so
```
<x> 
   <at><left/><parent/></at>
</x>
<y>
   <place><top/><edge/></place>
   <at><bottom/><predecessor/></at>
</y>
```
NOTE: This rule could be refined so that when the label long compared to x offset of the route the enclosure is offset. 

##### Rule 3B
Applies if the enclosure is the first enclosure within its parent enclosure and is NOT preceded by a label. For these enclosures,
```
<y>
   <place><top/><edge/></place>
   <at><top/><parent/></at>
</y>
```
We test this with a parent which is a group and has no label.
x smarts give:
```
<x>
   <place><left></place>
   <at><left/><parent/></at>
</x>
```

##### Rule 3C
Applies if the enclosure is not the first enclosure within its parent enclosure.
For these enclosures:
```
<y>
   <place><top/><edge/></place>
   <at><top/><predecessor/></at>
</y>
```
Smarts apply and therefore we get
```
<x>
   <place><left></place>
   <at><right/><predecessor/></at>
</x>
```
Rules test shows this y and subsequent x to be suboptimal.
Should be at the top of parent and to the left of previous placement to the parent.
How would we find this??? Maybe just preceding-sibling such that precondition holds.

#### Rule x5 (pass three)
Applies to any nested enclosure which is the first within its containing enclosure, to which rule y1 does nor apply and which is not the destination of a top down route whose source is outside of the containing enclosure. For these enclosures, place left of the parent enclosure
underneath the label as so
```
<x> 
 <at><left/><parent/></at>
</x>
<y>
 <place><top/><edge/></place>
   <at><bottom/><predecessor/>
   </at>
</y>
```

#### Rule x6A and x6B (pass four)
Apply to enclosures which are entry containers for topdown routes.
In particular there is a first-such-route. 
Rule x6A or rule x6B applies depending on whether
there is a preceding enclosure that is the entry container for a top down route with the same exit container as the first-such-route.  

##### Rule x6A
If there is no such preceding enclosure then line up the x cordinate of the enclosure with the exit container of the first-such-route.
```
<x> 
   <place><left/></place>
   <at><left/>
      <of>
         <xsl:value-of select="key('EnteringTopdownRoute',id)[1]/source/exitContainer"/>
      </of>
   </at>
</x>
```
##### Rule x6B
If there is such a preceding enclosure then place the enclosure to the right of the preceding enclosure 
```
<x> 
   <place>
      <left/>
   </place>
   <at>
      <right/>
      <of>
         <xsl:value-of select="preceding::enclosure
                  [key('EnteringTopdownRoute',id)[1]/source/exitContainer
                   =
                   key('EnteringTopdownRoute',current()/id)[1]/source/exitContainer
                  ][1]/id"/>
      </of>
   </at>
</x>
```
### Testing 
1. Construct and test on new examples in examplesER2flex.
2. Test on all examplesSelected

Debug brinton and some er2flex examples by changing the order of entity types in the source files. (Comments in the source files where this was necessary.) 

### Completion Date 
13 May 2025

### Future Action
Note in the day book 13 May 2025 describing how the ER2flex algorithm might be rewritten in a much better way.