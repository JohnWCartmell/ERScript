

## 2 June 2023 Part B - Remodel implementatonOf. 

### Summary
1. To the entity type `implementationOf` add a composition relationship :
`implementationOf => reached_by : navigation?`.
2. Populate `reached_by` within hierarchical physical models generated by logical2physical within the context of foreign key attributes for reference relationships that are implementations of destination attributes reached by identifying dependencies. 

### Rationale
`<xpath_evaluate>` generated for such reference relationships as described here, when tested (in the meta model), is faulty. To support the generation of the corrected `<xpath_evaluate>` it is desirable to have the `reached_by` navigation back to the host instance of the identifying attribute.   

### Discussion
#### I. current state of implmentationOf
Prior to this change and following the change of 26 May 2023 the following information held for a foreign key is
as follows:  
	```
	      <entity_type name="implementationOf">
	         <reference name="destAttr" type="attribute" diagonal="destAttrHostEt" riser=".."/>
	         <reference name="destAttrHostEt" type="entity_type" diagonal="^" riser="^"/>
	         <reference name="rel" type="reference_or_dependency" diagonal="../.." riser=".."/>
	         <composition name="reached_by" type="navigation?"/>
	      </entity_type>   
	```
#### II. the grossed up set of identifying attributes
0. This discussion is regarding hierarchal models (the situation is somewhat simpler in relational models).
1.   Consider that an entity e of type ET is in the first place (in the logical model) identified by the combination of (the values of) 
- a set of identifying attributes, AI, 
- and a set of identifying reference relationships, RI, 
- and a set of identifying depedencies, DI. 
2. This combined set of features identifies an entity too in the physical model but in order that an entity be identifiable solely by scalar values (so that reference relationships
with destination type ET may be implemented) we wish to define a grossed up set of identifying attributes which  suitable for identifying enities of type ET.
3. Therefore we are going to define for every entity type ET its grossed up set of identifying attributes. 
   By abuse of langauge we can say that
   each element of the grossed up set is a gross identifying attribute. Each one of these in the grossed up set for entity type ET
   is an attribute in the phsyical
   model and it is either an identifying attribute of the type ET (possible inherited from a supertype) or else it is an attribute of some ancestor of ET in the hierarchical structure i.e. one that is reached by steping up through dependency relationships through the compositional structure.
3. The grossed up set of identifying attributes is defined recursively.
4. In a hierarchical model any reference relationship r is represented physically by a set of implementing attributes and
if the relationship is identifying its implementing attributes are identifying. Call the set of all implmnenting attributes of identifying reference relationships AI+.
5. In a hierarchical model dependency relationships are NOT implemented by implementing attributes. Rather they are implemented by navigation up the hierarchical structure. If a dependency is identifying then to identify an entity 
from outside the scope of the destination of the dependency then it is necessary to identify that destination of the dependency
from the values of its gross identifying attributes. 
Let AI++ be the set of all gross identifying attributes reached along  an identifying dependency.
6. We can now consider that an entity e of type ET is identified by the combination of values of all of
- the set AI
- the set AI+
- the set of AI++

#### III. Implementation of reference relationships
In a hierarchical model a reference relationship with destination type ET is implemented by a set of implementing attributes
one for each of the gross identifying attributes AI | AI+ | AI++. In the case of an attribute implementing a member of AI++ there is no physical attribute at the destination end of the relationship rather there is a physical attribute of an ancestor entity reachable through a navigation up the structure. WE need follow this navigation to follow instances of the relationship and
so it is this that we wish to record this navigation in the meta model as the value of the new `reached_by` composition relationship. 

#### Proposal

1. Edit the meta model in `ERA..logical.xml`. Add `reached_by` to `implmentationOf` so as we have:
```
	      <entity_type name="implementationOf">
	         <reference name="destAttr" type="attribute" diagonal="destAttrHostEt" riser=".."/>
	         <reference name="destAttrHostEt" type="entity_type" diagonal="^" riser="^"/>
	         <reference name="rel" type="reference_or_dependency" diagonal="../.." riser=".."/>
	         <composition name="reached_by" type="navigation?"/>
	      </entity_type>   
```
Note that the `reached_by` path is to be evaluated within the context of any instance of the destination type of the reference relationship.

2. Modify `ERmodel.physical_enrichment.module.xslt` to populate the `reached_by` element as appropriate. 

3. Modify `ERmodel.physical_enrichment.module.xslt` so that the generated name of the implemented attribute corresponding to
grossed up attribute includes the name of the type reached for an identifying attribute rather than the type which
that attribute is  inherited from. 

4. Modify ERmodel2.xpath_enrichment to generated an `<xpath_evaluate>` element within the `reached_by/*` element. 
  
5. Incorporate  the generated `reached_by/*/xpath_evaluate` into the `<xpath_evaluate>` of reference relationships as necessary and as described in part E of this change.



#### Testing


1. Generate the meta model and inspect the implementing attribute for `identifying_relationship` with destination attribute the name of the identifying relationship's host entity type.
