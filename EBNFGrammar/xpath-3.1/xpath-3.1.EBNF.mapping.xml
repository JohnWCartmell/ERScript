<ebnf>
	<mapping>
		<replace production="PathExpr">
			<by>
				    <prod>
				         <lhs>PathExpr</lhs>
				         <rhs>
				            <or>
				               <nt>ContextualisedRelativePathExpr</nt>
				               <nt>RelativePathExpr</nt>
				            </or>
				         </rhs>
				    </prod>
				    <prod>
				         <lhs>ContextualisedRelativePathExpr</lhs>
				         <rhs>
				            <or>
				               <sequence>
				                  <literal>//</literal>
				                  <nt>RelativePathExpr</nt>
				               </sequence>
				               <sequence>
				                  <literal>/</literal>
				                  <ZeroOrOne>
				                     <nt>RelativePathExpr</nt>
				                  </ZeroOrOne>
				               </sequence>
				            </or>
				         </rhs>
				    </prod>
			</by>
		</replace>

		<replace production="AxisStep">
			<by> <!-- so as to be similar enough to AdditiveExpr  as enable associativeInfixTransform to apply -->
			      <prod>
			         <lhs>AxisStep</lhs>
			         <rhs>
			            <sequence>
			               <or>
			                  <nt>ReverseStep</nt>
			                  <nt>ForwardStep</nt>
			               </or>
			               <ZeroOneOrMore>
				               <literal>[</literal>
				               <nt>Expr</nt>
				               <literal>]</literal>
				            </ZeroOneOrMore>
			            </sequence>
			         </rhs>
			      </prod>
			</by>
		</replace>
        <replace production="NumericLiteral">
        	<by>
		      <prod>
		         <lhs>NumericLiteral</lhs>
		         <rhs>
		            <or>
		            	<nt>DoubleLiteral</nt>
		            	<nt>DecimalLiteral</nt>
		            	<nt>IntegerLiteral</nt>
		            </or>
		         </rhs>
		      </prod>
		  </by>
		</replace>
		<replace production="QuantifiedExpr">
			<by>
				<prod>
			         <lhs>QuantifiedExpr</lhs>
			         <rhs>
			            <sequence>
			               <or>
			                  <literal>some</literal>
			                  <literal>every</literal>
			               </or>
			               <nt>QuantifiedExprBinding</nt>
			               <literal>satisfies</literal>
			               <nt>ExprSingle</nt>
			           </sequence>
			       </rhs>
			   </prod>
		     	<prod>
		     		<lhs>QuantifiedExprBinding</lhs>
		     		<rhs>
		     			<sequence>
		     				<nt>SimpleForBinding</nt>
			               <ZeroOneOrMore>
			                  <literal>,</literal>
			                  <nt>SimpleForBinding</nt>
			               </ZeroOneOrMore>
			           </sequence>
		     		</rhs>
		     	</prod>
		 	</by>
		</replace>
		<replace production="Wildcard">
			<by>
		      <prod>
		         <lhs>Wildcard</lhs>
		         <rhs whitespace="explicit">   <!-- This line is changed by addition of whitespace="explicit"> -->
		            <or>
		               <literal>*</literal>
		               <sequence>
		                  <nt>NCName</nt>
		                  <literal>:*</literal>
		               </sequence>
		               <sequence>
		                  <literal>*:</literal>
		                  <nt>NCName</nt>
		               </sequence>
		               <sequence>
		                  <nt>BracedURILiteral</nt>
		                  <literal>*</literal>
		               </sequence>
		            </or>
		         </rhs>
		         <com>
		            <loc xmlns:xlink="http://www.w3.org/1999/xlink">ws: explicit</loc>
		         </com>
		      </prod>
		  </by>
	</replace>
	<replace production="PrimaryExpr">
		<by>
	      <prod>
	         <lhs>PrimaryExpr</lhs>
	         <rhs>
	            <or>
	               <nt>Literal</nt>
	               <nt>VarRef</nt>
	               <nt>ParenthesizedExpr</nt>
	               <nt>ContextItemExpr</nt>
	               <nt>FunctionItemExpr</nt> <!-- this brought forward before function call-->
	               <nt>FunctionCall</nt>
	               <nt>MapConstructor</nt>
	               <nt>ArrayConstructor</nt>
	               <nt>UnaryLookup</nt>
	            </or>
	         </rhs>
	      </prod>
	  	</by>
	</replace>
	<replace production="ArrowExpr">
		<by>
			<prod>
		         <lhs>ArrowExpr</lhs>
		         <rhs>
		            <sequence>
		               <nt>UnaryExpr</nt>
		               <ZeroOneOrMore>
		                  <nt>ArrowStep</nt>
		               </ZeroOneOrMore>
		            </sequence>
		         </rhs>
		    </prod>
		    <prod>
		         <lhs>ArrowStep</lhs>
		         <rhs>
		            <sequence>
		                  <literal>=&gt;</literal>
		                  <nt>ArrowFunctionSpecifier</nt>
		                  <nt>ArgumentList</nt>
		            </sequence>
		         </rhs>
		    </prod>
		</by>
    </replace>

	<replace production="ArrowFunctionSpecifier">
		<by>
	      <prod>
	         <lhs>ArrowFunctionSpecifier</lhs>
	         <rhs>
	            <or>
	               <nt>StaticArrowStep</nt>
	               <nt>VariableArrowStep</nt>
	               <nt>CalculatedArrowStep</nt>
	            </or>
	         </rhs>
	      </prod>
	      <prod>
		        <lhs>StaticArrowStep</lhs>
		        <rhs>   
		        	<nt>EQName</nt>
		        </rhs>
	      </prod>
	      <prod>
		        <lhs>VariableArrowStep</lhs>
		        <rhs> 
		        	<nt>VarRef</nt>
		        </rhs>
	      </prod>
	      <prod>
		        <lhs>CalculatedArrowStep</lhs>
		        <rhs>	        	
               		<nt>ParenthesizedExpr</nt>
		        </rhs>
	      </prod>
	  </by>
	</replace>


		<non-terminals>
			<non-terminal name="fred"/>
		</non-terminals>

		<non-terminals>
			<non-terminal name="AdditiveExpr"        transform="associativeInfixTransform" abstract="when_singular"/>
			<non-terminal name="AndExpr"             transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="Argument"                                       abstract="unconditional"/>    
            <non-terminal name="ArgumentList"         nameWhenAnonymousOperator="DynamicFunctionCall" transform="separatedListTransform"/> 
            <non-terminal name="ArrayConstructor"                               abstract="unconditional"/>    
            <non-terminal name="ArrowExpr"            transform="separatedListTransform"  abstract="when_singular"/>  
            <non-terminal name="ArrowFunctionSpecifier"                         abstract="unconditional"/>
            <non-terminal name="AxisStep"            transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="CastExpr"                                       abstract="when_singular"/>
            <non-terminal name="CastableExpr"                                   abstract="when_singular"/>
            <non-terminal name="ContextualisedRelativePathExpr" transform="prefixTransform" abstract="when_singular"/>
			<non-terminal name="ComparisonExpr"      transform="infixTransform"            abstract="when_singular"/>
            <non-terminal name="EQName"                                         abstract="unconditional"/>
            <non-terminal name="ElementNameOrWildcard"                                         abstract="unconditional"/>
            <non-terminal name="Expr"                transform="separatedListTransform" />
            <non-terminal name="ExprSingle"                                     abstract="unconditional"/>
            <non-terminal name="FunctionItemExpr"                               abstract="unconditional"/>
            <non-terminal name="GeneralComp"                                    abstract="unconditional"/> 
            <non-terminal name="InstanceofExpr"                                 abstract="when_singular"/>
			<non-terminal name="IntersectExceptExpr" transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="ItemType"                                       abstract="unconditional"/>
            <non-terminal name="KindTest"                                       abstract="unconditional"/>
            <non-terminal name="Literal"                                        abstract="unconditional"/>
            <non-terminal name="MapConstructor"                transform="separatedListTransform" />
            <non-terminal name="MultiplicativeExpr"  transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="NodeComp"                                       abstract="unconditional"/>  
            <non-terminal name="NodeTest"                                       abstract="unconditional"/>
            <non-terminal name="NumericLiteral"                                 abstract="unconditional"/>
            <non-terminal name="OrExpr"              transform="associativeInfixTransform" abstract="when_singular"/> 
            <non-terminal name="ParamList"           transform="separatedListTransform"                 />       
            <non-terminal name="ParenthesizedExpr"                              abstract="unconditional"/>
            <non-terminal name="PathExpr"                                     	abstract="unconditional"/>
            <non-terminal name="PostfixExpr"         transform="associativeAnonymousInfixTransform" abstract="when_singular"/>
            <non-terminal name="Predicate"           nameWhenAnonymousOperator="PredicativeExpr"         />      
            <non-terminal name="PrimaryExpr"                                    abstract="unconditional"/>
            <non-terminal name="QuantifiedExpr"      transform="prefixTransform"                        />
            <non-terminal name="QuantifiedExprBinding" transform="separatedListTransform"               /> 
            <non-terminal name="RangeExpr"                                      abstract="when_singular"/>
            <non-terminal name="RelativePathExpr"    transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="StepExpr"                                       abstract="unconditional"/>
            <non-terminal name="SimpleForClause"     transform="separatedListTransform"                 /> 
            <non-terminal name="SimpleLetClause"     transform="separatedListTransform"                 /> 
            <non-terminal name="SimpleMapExpr"       transform="associativeInfixTransform"  abstract="when_singular"/>
            <non-terminal name="StringConcatExpr"    transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="TreatExpr"                                      abstract="when_singular"/>
            <non-terminal name="UnaryExpr"           transform="multiPrefixTransform"  abstract="when_singular"/>
            <non-terminal name="UnionExpr"           transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="VarName"                                        abstract="unconditional"/>
            <non-terminal name="ValueComp"                                      abstract="unconditional"/>
            <non-terminal name="ValueExpr"                                      abstract="unconditional"/>
       </non-terminals>
		<literalMapping>
		   <production>AdditiveExpr</production>
		   <literal>+</literal>
		   <mapping>BinaryAdd</mapping>
		</literalMapping>
		<literalMapping>
		   <production>AdditiveExpr</production>
		   <literal>-</literal>
		   <mapping>BinarySubtract</mapping>
		</literalMapping>
		<literalMapping>
		   <production>MultiplicativeExpr</production>
		   <literal>*</literal>
		   <mapping>BinaryMultiply</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnionExpr</production>
		   <literal>|</literal>
		   <mapping>BinaryUnion</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnaryExpr</production>
		   <literal>-</literal>
		   <mapping>UnaryMinus</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnaryExpr</production>
		   <literal>+</literal>
		   <mapping>UnaryPlus</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>=</literal>
		   <mapping>somewhat_eq</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>!=</literal>
		   <mapping>Somewhat_ne</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&lt;</literal>
		   <mapping>Somewhat_lt</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&lt;=</literal>
		   <mapping>Somewhat_leq</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&gt;</literal>
		   <mapping>Somewhat_gt</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&gt;=</literal>
		   <mapping>Somewhat_gte</mapping>
		</literalMapping>
		<literalMapping>
		   <production>NodeComp</production>
		   <literal>&lt;&lt;</literal>
		   <mapping>BinaryPrecedes</mapping>
		</literalMapping>
		<literalMapping>
		   <production>NodeComp</production>
		   <literal>&gt;&gt;</literal>
		   <mapping>BinaryIsPrecededBy</mapping>
		</literalMapping>
		<literalMapping>
		   <production>SimpleMapExpr</production>
		   <literal>!</literal>
		   <mapping>SimpleMap</mapping>
		</literalMapping>
		<literalMapping>
		   <production>RelativePathExpr</production>
		   <literal>/</literal>
		   <mapping>BinaryCompose</mapping>
		</literalMapping>
		<literalMapping>
		   <production>RelativePathExpr</production>
		   <literal>//</literal>
		   <mapping>BinaryReachAndCompose</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ContextualisedRelativePathExpr</production>
		   <literal>/</literal>
		   <mapping>Root</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ContextualisedRelativePathExpr</production>
		   <literal>//</literal>
		   <mapping>RootReach</mapping>
		</literalMapping>
		<literalMapping>
		   <production>Wildcard</production>
		   <literal>*</literal>
		   <mapping>Wildcard_1</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>?</literal>
		   <mapping>OccursZeroOrOne</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>*</literal>
		   <mapping>OccursZeroONeOrMore</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>+</literal>
		   <mapping>OccursOneOrMore</mapping>
		</literalMapping>
		<literalMapping>
		   <production>AttribNameOrWildcard</production>
		   <literal>*</literal>
		   <mapping>Wildcard_for_AttributeName_in_AttribNameOrWildcard</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ElementNameOrWildcard</production>
		   <literal>*</literal>
		   <mapping>Wildcard_for_ElementName_in_ElementNameOrWildcard</mapping>
		</literalMapping>
		<!--
		<literalMapping>
		   <production>Predicate</production>
		   <literal>[</literal>
		   <mapping>ApplyPredicate</mapping>
		</literalMapping>
	-->
		<literalMapping>
		   <production>AxisStep</production>
		   <literal>[</literal>
		   <mapping>PredicatedStep</mapping>
		</literalMapping>
		<!--
		<literalMapping>
		   <production>ArgumentList</production>
		   <literal>(</literal>
		   <mapping>DynamicFunctionCall</mapping>
		</literalMapping>
	-->
		<literalMapping>
		   <production>DecimalLiteral</production>
		   <literal>.</literal>
		   <mapping>DecimalSeparator</mapping>
		</literalMapping>
		<literalMapping>
		   <production>DoubleLiteral</production>
		   <literal>.</literal>
		   <mapping>DecimalSeparator</mapping>
		</literalMapping>
		<literalMapping>
		   <production>Wildcard</production>
		   <literal>:</literal>
		   <mapping>PrefixesReview</mapping>
		</literalMapping>
	</mapping>
</ebnf>
