<ebnf>
	<mapping>
		<replace production="PathExpr">
			<by>
				    <prod>
				         <lhs>PathExpr</lhs>
				         <rhs>
				            <or>
				               <nt>ContextualisedRelativePathExpr</nt>
				               <nt>RelativePathExpr</nt>
				            </or>
				         </rhs>
				    </prod>
				    <prod>
				         <lhs>ContextualisedRelativePathExpr</lhs>
				         <rhs>
				            <or>
				               <sequence>
				                  <literal>//</literal>
				                  <nt>RelativePathExpr</nt>
				               </sequence>
				               <sequence>
				                  <literal>/</literal>
				                  <ZeroOrOne>
				                     <nt>RelativePathExpr</nt>
				                  </ZeroOrOne>
				               </sequence>
				            </or>
				         </rhs>
				    </prod>
			</by>
		</replace>

		<replace production="AxisStep">
			<by> <!-- so as to be similar enough to AdditiveExpr  as enable associativeInfixTransform to apply -->
			      <prod>
			         <lhs>AxisStep</lhs>
			         <rhs>
			            <sequence>
			               <or>
			                  <nt>ReverseStep</nt>
			                  <nt>ForwardStep</nt>
			               </or>
			               <ZeroOneOrMore>
				               <literal>[</literal>
				               <nt>Expr</nt>
				               <literal>]</literal>
				            </ZeroOneOrMore>
			            </sequence>
			         </rhs>
			      </prod>
			</by>
		</replace>
        <replace production="NumericLiteral">
        	<by>
		      <prod>
		         <lhs>NumericLiteral</lhs>
		         <rhs>
		            <or>
		            	<nt>DoubleLiteral</nt>
		            	<nt>DecimalLiteral</nt>
		            	<nt>IntegerLiteral</nt>
		            </or>
		         </rhs>
		      </prod>
		  </by>
		</replace>

		<non-terminals>
			<non-terminal name="AdditiveExpr"        transform="associativeInfixTransform" abstract="when_singular"/>
			<non-terminal name="AndExpr"             transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="ArgumentList"         nameWhenAnonymousOperator="DynamicFunctionCall" transform="separatedListTransform"/> 
            <non-terminal name="ArrayConstructor"                               abstract="unconditional"/>    
            <non-terminal name="ArrowExpr"                                      abstract="when_singular"/>  
            <non-terminal name="ArrowFunctionSpecifier"                         abstract="unconditional"/>
            <non-terminal name="AxisStep"            transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="CastExpr"                                       abstract="when_singular"/>
            <non-terminal name="CastableExpr"                                   abstract="when_singular"/>
            <non-terminal name="ContextualisedRelativePathExpr" transform="prefixTransform" abstract="when_singular"/>
			<non-terminal name="ComparisonExpr"      transform="infixTransform"            abstract="when_singular"/>
            <non-terminal name="EQName"                                         abstract="unconditional"/>
            <non-terminal name="ElementNameOrWildcard"                                         abstract="unconditional"/>
            <non-terminal name="Expr"                transform="separatedListTransform" />
            <non-terminal name="ExprSingle"                                     abstract="unconditional"/>
            <non-terminal name="FunctionItemExpr"                               abstract="unconditional"/>
            <non-terminal name="GeneralComp"                                    abstract="unconditional"/> 
            <non-terminal name="InstanceofExpr"                                 abstract="when_singular"/>
			<non-terminal name="IntersectExceptExpr" transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="ItemType"                                       abstract="unconditional"/>
            <non-terminal name="KindTest"                                       abstract="unconditional"/>
            <non-terminal name="Literal"                                        abstract="unconditional"/>
            <non-terminal name="MultiplicativeExpr"  transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="NodeComp"                                       abstract="unconditional"/>  
            <non-terminal name="NodeTest"                                       abstract="unconditional"/>
            <non-terminal name="NumericLiteral"                                 abstract="unconditional"/>
            <non-terminal name="OrExpr"              transform="associativeInfixTransform" abstract="when_singular"/> 
            <non-terminal name="ParamList"           transform="separatedListTransform" />       
            <non-terminal name="ParenthesizedExpr"                              abstract="unconditional"/>
            <non-terminal name="PathExpr"                                     	abstract="unconditional"/>
            <non-terminal name="PostfixExpr"         transform="associativeAnonymousInfixTransform" abstract="when_singular"/>
            <non-terminal name="Predicate"           nameWhenAnonymousOperator="ApplyPredicate" />      
            <non-terminal name="PrimaryExpr"                                    abstract="unconditional"/>
            <non-terminal name="RangeExpr"                                      abstract="when_singular"/>
            <non-terminal name="RelativePathExpr"    transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="StepExpr"                                       abstract="unconditional"/>
            <non-terminal name="SimpleMapExpr"       transform="associativeInfixTransform"  abstract="when_singular"/>
            <non-terminal name="StringConcatExpr"    transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="TreatExpr"                                      abstract="when_singular"/>
            <non-terminal name="UnaryExpr"           transform="multiPrefixTransform"  abstract="when_singular"/>
            <non-terminal name="UnionExpr"           transform="associativeInfixTransform" abstract="when_singular"/>
            <non-terminal name="VarName"                                        abstract="unconditional"/>
            <non-terminal name="ValueComp"                                      abstract="unconditional"/>
            <non-terminal name="ValueExpr"                                      abstract="unconditional"/>
       </non-terminals>
		<literalMapping>
		   <production>AdditiveExpr</production>
		   <literal>+</literal>
		   <mapping>BinaryAdd</mapping>
		</literalMapping>
		<literalMapping>
		   <production>AdditiveExpr</production>
		   <literal>-</literal>
		   <mapping>BinarySubtract</mapping>
		</literalMapping>
		<literalMapping>
		   <production>MultiplicativeExpr</production>
		   <literal>*</literal>
		   <mapping>BinaryMultiply</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnionExpr</production>
		   <literal>|</literal>
		   <mapping>BinaryUnion</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnaryExpr</production>
		   <literal>-</literal>
		   <mapping>UnaryMinus</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnaryExpr</production>
		   <literal>+</literal>
		   <mapping>UnaryPlus</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>=</literal>
		   <mapping>GeneralEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>!=</literal>
		   <mapping>GenerallyNotEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&lt;</literal>
		   <mapping>GenerallyLessThan</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&lt;=</literal>
		   <mapping>GenerallyLessThanOrEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&gt;</literal>
		   <mapping>GenerallyGreaterThan</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&gt;=</literal>
		   <mapping>GenerallyGreaterThanOrEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>NodeComp</production>
		   <literal>&lt;&lt;</literal>
		   <mapping>BinaryPrecedes</mapping>
		</literalMapping>
		<literalMapping>
		   <production>NodeComp</production>
		   <literal>&gt;&gt;</literal>
		   <mapping>BinaryIsPrecededBy</mapping>
		</literalMapping>
		<literalMapping>
		   <production>SimpleMapExpr</production>
		   <literal>!</literal>
		   <mapping>BinaryMap</mapping>
		</literalMapping>
		<literalMapping>
		   <production>RelativePathExpr</production>
		   <literal>/</literal>
		   <mapping>BinaryCompose</mapping>
		</literalMapping>
		<literalMapping>
		   <production>RelativePathExpr</production>
		   <literal>//</literal>
		   <mapping>BinaryReachAndCompose</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ContextualisedRelativePathExpr</production>
		   <literal>/</literal>
		   <mapping>Root</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ContextualisedRelativePathExpr</production>
		   <literal>//</literal>
		   <mapping>RootReach</mapping>
		</literalMapping>
		<literalMapping>
		   <production>Wildcard</production>
		   <literal>*</literal>
		   <mapping>Wildcard_1</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>?</literal>
		   <mapping>OccursZeroOrOne</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>*</literal>
		   <mapping>OccursZeroONeOrMore</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>+</literal>
		   <mapping>OccursOneOrMore</mapping>
		</literalMapping>
		<literalMapping>
		   <production>AttribNameOrWildcard</production>
		   <literal>*</literal>
		   <mapping>Wildcard_2</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ElementNameOrWildcard</production>
		   <literal>*</literal>
		   <mapping>Wildcard_3</mapping>
		</literalMapping>
		<!--
		<literalMapping>
		   <production>Predicate</production>
		   <literal>[</literal>
		   <mapping>ApplyPredicate</mapping>
		</literalMapping>
	-->
		<literalMapping>
		   <production>AxisStep</production>
		   <literal>[</literal>
		   <mapping>ApplyPredicateToStep</mapping>
		</literalMapping>
		<!--
		<literalMapping>
		   <production>ArgumentList</production>
		   <literal>(</literal>
		   <mapping>DynamicFunctionCall</mapping>
		</literalMapping>
	-->
		<literalMapping>
		   <production>DecimalLiteral</production>
		   <literal>.</literal>
		   <mapping>DecimalSeparator</mapping>
		</literalMapping>
		<literalMapping>
		   <production>DoubleLiteral</production>
		   <literal>.</literal>
		   <mapping>DecimalSeparator</mapping>
		</literalMapping>
		<literalMapping>
		   <production>Wildcard</production>
		   <literal>:</literal>
		   <mapping>PrefixesReview</mapping>
		</literalMapping>
	</mapping>
</ebnf>
