<ebnf>
	<mapping>
		<replace production="PathExpr">
			<by>
				    <prod>
				         <lhs>PathExpr</lhs>
				         <rhs>
				            <or>
				               <nt>ContextualisedRelativePathExpr</nt>
				               <nt>RelativePathExpr</nt>
				            </or>
				         </rhs>
				    </prod>
				    <prod>
				         <lhs>ContextualisedRelativePathExpr</lhs>
				         <rhs>
				            <or>
				               <sequence>
				                  <literal>//</literal>
				                  <nt>RelativePathExpr</nt>
				               </sequence>
				               <sequence>
				                  <literal>/</literal>
				                  <ZeroOrOne>
				                     <nt>RelativePathExpr</nt>
				                  </ZeroOrOne>
				               </sequence>
				            </or>
				         </rhs>
				    </prod>
			</by>
		</replace>

		<non-terminals>
			<non-terminal name="OrExpr"              transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="AndExpr"             transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="ComparisonExpr"      transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="AdditiveExpr"        transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="MultiplicativeExpr"  transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="UnionExpr"           transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="IntersectExceptExpr" transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="StringConcatExpr"    transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="RelativePathExpr"    transform="infixTransform" abstract="when_singular"/>
			<non-terminal name="PostfixExpr"    	 transform="infixTransform" abstract="when_singular"/>
            <non-terminal name="RangeExpr"                                      abstract="when_singular"/>
			<non-terminal name="UnaryExpr"           transform="multiPrefixTransform"  abstract="when_singular"/>
			<non-terminal name="InstanceofExpr"                                 abstract="when_singular"/>
			<non-terminal name="CastExpr"                                       abstract="when_singular"/>
			<non-terminal name="CastableExpr"                                   abstract="when_singular"/>
			<non-terminal name="TreatExpr"                                      abstract="when_singular"/>
			<non-terminal name="SimpleMapExpr"       transform="infixTransform"  abstract="when_singular"/>
			<non-terminal name="ContextualisedRelativePathExpr" transform="prefixTransform" abstract="when_singular"/>
			<non-terminal name="ArrowExpr"                                      abstract="when_singular"/>
            <non-terminal name="ExprSingle"                                     abstract="unconditional"/>
            <non-terminal name="PathExpr"                                     	abstract="unconditional"/>
            <non-terminal name="GeneralComp"                                    abstract="unconditional"/>
            <non-terminal name="ValueComp"                                      abstract="unconditional"/>
            <non-terminal name="NodeComp"                                       abstract="unconditional"/>
            <non-terminal name="StepExpr"                                       abstract="unconditional"/>
            <non-terminal name="ForwardStep"                                    abstract="unconditional"/>
            <non-terminal name="ReverseStep"                                    abstract="unconditional"/>
            <non-terminal name="NodeTest"                                       abstract="unconditional"/>
            <non-terminal name="NameTest"                                       abstract="unconditional"/>
            <non-terminal name="Predicate"                                      abstract="unconditional"/>
            <non-terminal name="ArgumentList"                                   abstract="unconditional"/>
            <non-terminal name="ArrowFunctionSpecifier"                         abstract="unconditional"/>
            <non-terminal name="PrimaryExpr"                                    abstract="unconditional"/>
            <non-terminal name="Literal"                                        abstract="unconditional"/>
            <non-terminal name="NumericLiteral"                                 abstract="unconditional"/>
            <non-terminal name="VarName"                                        abstract="unconditional"/>
            <non-terminal name="Argument"                                       abstract="unconditional"/>
            <non-terminal name="FunctionItemExpr"                               abstract="unconditional"/>
            <non-terminal name="ParenthesizedExpr"                              abstract="unconditional"/>
            <non-terminal name="ValueExpr"                                      abstract="unconditional"/>
            <non-terminal name="ArrayConstructor"                               abstract="unconditional"/>
            <non-terminal name="KindTest"                                       abstract="unconditional"/>
            <non-terminal name="EQName"                                         abstract="unconditional"/>
       </non-terminals>
		<literalMapping>
		   <production>AdditiveExpr</production>
		   <literal>+</literal>
		   <mapping>BinaryAdd</mapping>
		</literalMapping>
		<literalMapping>
		   <production>AdditiveExpr</production>
		   <literal>-</literal>
		   <mapping>BinarySubtract</mapping>
		</literalMapping>
		<literalMapping>
		   <production>MultiplicativeExpr</production>
		   <literal>*</literal>
		   <mapping>BinaryMultiply</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnionExpr</production>
		   <literal>|</literal>
		   <mapping>BinaryUnion</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnaryExpr</production>
		   <literal>-</literal>
		   <mapping>UnaryMinus</mapping>
		</literalMapping>
		<literalMapping>
		   <production>UnaryExpr</production>
		   <literal>+</literal>
		   <mapping>UnaryPlus</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>=</literal>
		   <mapping>GeneralEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>!=</literal>
		   <mapping>GenerallyNotEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&lt;</literal>
		   <mapping>GenerallyLessThan</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&lt;=</literal>
		   <mapping>GenerallyLessThanOrEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&gt;</literal>
		   <mapping>GenerallyGreaterThan</mapping>
		</literalMapping>
		<literalMapping>
		   <production>GeneralComp</production>
		   <literal>&gt;=</literal>
		   <mapping>GenerallyGreaterThanOrEquals</mapping>
		</literalMapping>
		<literalMapping>
		   <production>NodeComp</production>
		   <literal>&lt;&lt;</literal>
		   <mapping>BinaryPrecedes</mapping>
		</literalMapping>
		<literalMapping>
		   <production>NodeComp</production>
		   <literal>&gt;&gt;</literal>
		   <mapping>BinaryIsPrecededBy</mapping>
		</literalMapping>
		<literalMapping>
		   <production>SimpleMapExpr</production>
		   <literal>!</literal>
		   <mapping>BinaryMap</mapping>
		</literalMapping>
		<literalMapping>
		   <production>RelativePathExpr</production>
		   <literal>/</literal>
		   <mapping>BinaryCompose</mapping>
		</literalMapping>
		<literalMapping>
		   <production>RelativePathExpr</production>
		   <literal>//</literal>
		   <mapping>BinaryReachAndCompose</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ContextualisedRelativePathExpr</production>
		   <literal>/</literal>
		   <mapping>Root</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ContextualisedRelativePathExpr</production>
		   <literal>//</literal>
		   <mapping>RootReach</mapping>
		</literalMapping>
		<literalMapping>
		   <production>Wildcard</production>
		   <literal>*</literal>
		   <mapping>WidlcardReview</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>?</literal>
		   <mapping>OccursZeroOrOne</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>*</literal>
		   <mapping>OccursZeroONeOrMore</mapping>
		</literalMapping>
		<literalMapping>
		   <production>OccurrenceIndicator</production>
		   <literal>+</literal>
		   <mapping>OccursOneOrMore</mapping>
		</literalMapping>
		<literalMapping>
		   <production>AttribNameOrWildcard</production>
		   <literal>*</literal>
		   <mapping>WildcardTwoReview</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ElementNameOrWildcard</production>
		   <literal>*</literal>
		   <mapping>WildcardThreeReview</mapping>
		</literalMapping>
		<literalMapping>
		   <production>Predicate</production>
		   <literal>[</literal>
		   <mapping>ApplyPredicate</mapping>
		</literalMapping>
		<literalMapping>
		   <production>ArgumentList</production>
		   <literal>(</literal>
		   <mapping>DynamicFunctionCall</mapping>
		</literalMapping>
	</mapping>
</ebnf>
