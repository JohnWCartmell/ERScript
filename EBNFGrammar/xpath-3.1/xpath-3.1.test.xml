<ebnf>
    <include_grammar filename="xpath-3.1.EBNF.lexis.xml"/>
	<include_grammar filename="xpath-3.1.EBNF.grammar.IDL.xml"/>
	<include_mapping filename="xpath-3.1.EBNF.mapping.xml"/>


    <test>
    	<rhs><nt>Expr</nt></rhs>
		<xpath>(/*, /*:b, /b:*, /Q{URI}*) 
		</xpath>
	</test>


<!--
	
(/*,/*:b,/b:*,/Q{URI}*) 

//*[@id="tsf"]/div[2]/div[3]/center/input[1]
    <test>
    	<rhs><nt>Expr</nt></rhs>
		<xpath>
			map {			
		'AbbrevForwardStep' 	: (x, prfx:x, Q{uri}x, Q{}x )
		'AddExpr' 				: $x + self::y + child::z,	
		'AndExpr'				: x and y,
		'ArrowExpr' 			: $string => upper-case() => normalize-unicode() => tokenize('\s+'),
		'CastExpr' 				: '999' cast as xs:integer?,
		'CastableExpr'			: 'xxx' castable as xs:boolean,
		'DecimalLiteral'    	: 1.13,
        'DoubleLiteral' 		: 1.2E3,
        'DoubleQuotedString' 	: "This is a double quoted literal here is an escaped double quote "". This literal includes spaces.",
        'DynamicFunctionCall' 	: $x(a,b,c)(d,e,f),
		'EveryExpr' 			: every $x in $xset satisfies some $y in $yset satisfies  $x and $y,
        'ForExpr' 				: for $x in $xset, $y in $yset return $x + $y, 		
		'ForwardStep'       	: child::a,
		'GeneralComp'			: (1 &lt; 2, 1 = 2, 1 &gt; 2, 1 != 2),
        'IfExpr'         	 	: if ($C) then $E1 else $E2,
		'InlineFunctionExpr' 	: function($a as xs:double, $b as xs:double) as xs:double { $a * $b },
		'InstanceofExpr' 		: (w instance of element(), x instance of empty-sequence(), y instance of element(para), (5,6) instance of element(*)),
		'IntegerLiteral'		: 2,	
		'IntersectExpr' 		: x intersect y,
	    'LetExpr' 				: let $x := y return z,
	    'NodeComp'				: ($x &lt;&lt; $y, $x is $y, $x &gt;&gt; $y),
	    'OrExpr'				: x or y or w and z,
		'PostfixExpr' 			: $x[y](a,b,c)[z],
		'PostfixLookup' 		: ($map?xyz, $array?1, $array?(1,2), $mapOrArray?*),
		'PredicatedExpr'        : $a[b][c],
        'PredicatedStep' 		: child::para[position() = 1],
        'ReachingCompose' 		: a//b,
        'Root' 					: /,
        'RootedPathExpr' 		: /a/b/c,
        'RootedReachPathExpr' 	: //a/b/c,
		'SingleQuotedString' 	: 'This is a single quoted literal here is an escaped single quote ''. This literal includes spaces.',
		'SimpleMapExpr' 		: $values!(.*.),
        'SquareArrayConstructor': [1,2,3],
		'TreatExpr' 			: 'xxx' treat as xs:boolean?,
		'UnaryExpr'     		: (-4, - - $x, - + $y),
		'UnaryLookup' : (?a,?1,?(1,2),?*),
		'UnionExpr' 			: x union y | z,
		'ValueComp'				: (1 eq 2, 1 ne 2),
		'exampleusingArgumentPlaceholder' : let $sum-of-squares := fn:fold-right(?, 0, function($a, $b) { $a*$a + $b }) return $sum-of-squares(1 to 3),
		'examplefromtheweb' : //*[@id="tsf"]/div[2]/div[3]/center/input[1]
		 }
		</xpath>
	</test>
-->

</ebnf>

