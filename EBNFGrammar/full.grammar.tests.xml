<?xml version="1.0" encoding="UTF-8"?>
<ebnf>
<grammar>
   <prod>
      <lhs>XPath</lhs>
      <rhs>
         <nt>Expr</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>ParamList</lhs>
      <rhs>
         <sequence>
            <nt>Param</nt>
            <ZeroOneOrMore>
               <literal>,</literal>
               <nt>Param</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>Param</lhs>
      <rhs>
         <sequence>
            <literal>$</literal>
            <nt>EQName</nt>
            <ZeroOrOne>
               <nt>TypeDeclaration</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>FunctionBody</lhs>
      <rhs>
         <nt>EnclosedExpr</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>EnclosedExpr</lhs>
      <rhs>
         <sequence>
            <literal>{</literal>
            <nt>Expr</nt>
            <literal>}</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>Expr</lhs>
      <rhs>
         <sequence>
            <nt>ExprSingle</nt>
            <ZeroOneOrMore>
               <literal>,</literal>
               <nt>ExprSingle</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ExprSingle</lhs>
      <or>
         <nt>ForExpr</nt>
         <nt>LetExpr</nt>
         <nt>QuantifiedExpr</nt>
         <nt>IfExpr</nt>
         <nt>OrExpr</nt>
      </or>
   </prod>
   <prod>
      <lhs>ForExpr</lhs>
      <rhs>
         <sequence>
            <nt>SimpleForClause</nt>
            <literal>return</literal>
            <nt>ExprSingle</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>SimpleForClause</lhs>
      <rhs>
         <sequence>
            <literal>for</literal>
            <nt>SimpleForBinding</nt>
            <ZeroOneOrMore>
               <literal>,</literal>
               <nt>SimpleForBinding</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>SimpleForBinding</lhs>
      <rhs>
         <sequence>
            <literal>$</literal>
            <nt>VarName</nt>
            <literal>in</literal>
            <nt>ExprSingle</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>LetExpr</lhs>
      <rhs>
         <sequence>
            <nt>SimpleLetClause</nt>
            <literal>return</literal>
            <nt>ExprSingle</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>SimpleLetClause</lhs>
      <rhs>
         <sequence>
            <literal>let</literal>
            <nt>SimpleLetBinding</nt>
            <ZeroOneOrMore>
               <literal>,</literal>
               <nt>SimpleLetBinding</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>SimpleLetBinding</lhs>
      <rhs>
         <sequence>
            <literal>$</literal>
            <nt>VarName</nt>
            <literal>:=</literal>
            <nt>ExprSingle</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>QuantifiedExpr</lhs>
      <rhs>
         <sequence>
            <or>
               <literal type="Some">some</literal>
               <literal type="Every">every</literal>
            </or>
            <literal>$</literal>
            <nt>VarName</nt>
            <literal>in</literal>
            <nt>ExprSingle</nt>
            <ZeroOneOrMore>
               <literal>,</literal>
               <literal>$</literal>
               <nt>VarName</nt>
               <literal>in</literal>
               <nt>ExprSingle</nt>
            </ZeroOneOrMore>
            <literal>satisfies</literal>
            <nt>ExprSingle</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>IfExpr</lhs>
      <rhs>
         <sequence>
            <literal>if</literal>
            <literal>(</literal>
            <nt>Expr</nt>
            <literal>)</literal>
            <literal>then</literal>
            <nt>ExprSingle</nt>
            <literal>else</literal>
            <nt>ExprSingle</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>OrExpr</lhs>
      <rhs>
         <sequence>
            <nt>AndExpr</nt>
            <ZeroOneOrMore>
               <literal>or</literal>
               <nt>AndExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>AndExpr</lhs>
      <rhs>
         <sequence>
            <nt>ComparisonExpr</nt>
            <ZeroOneOrMore>
               <literal>and</literal>
               <nt>ComparisonExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ComparisonExpr</lhs>
      <rhs>
         <sequence>
            <nt>StringConcatExpr</nt>
            <ZeroOrOne>
               <or>
                  <nt>ValueComp</nt>
                  <nt>GeneralComp</nt>
                  <nt>NodeComp</nt>
               </or>
               <nt>StringConcatExpr</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>StringConcatExpr</lhs>
      <rhs>
         <sequence>
            <nt>RangeExpr</nt>
            <ZeroOneOrMore>
               <literal>||</literal>
               <nt>RangeExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>RangeExpr</lhs>
      <rhs>
         <sequence>
            <nt>AdditiveExpr</nt>
            <ZeroOrOne>
               <literal>to</literal>
               <nt>AdditiveExpr</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>AdditiveExpr</lhs>
      <rhs>
         <sequence>
            <nt>MultiplicativeExpr</nt>
            <ZeroOneOrMore>
               <or>
                  <literal type="Add">+</literal>
                  <literal type="Substract">-</literal>
               </or>
               <nt>MultiplicativeExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>MultiplicativeExpr</lhs>
      <rhs>
         <sequence>
            <nt>UnionExpr</nt>
            <ZeroOneOrMore>
               <or>
                  <literal type="Multiply">*</literal>
                  <literal type="Div">div</literal>
                  <literal type="Idiv">idiv</literal>
                  <literal type="Mod">mod</literal>
               </or>
               <nt>UnionExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>UnionExpr</lhs>
      <rhs>
         <sequence>
            <nt>IntersectExceptExpr</nt>
            <ZeroOneOrMore>
               <or>
                  <literal type="Union">union</literal>
                  <literal type="Union">|</literal>
               </or>
               <nt>IntersectExceptExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>IntersectExceptExpr</lhs>
      <rhs>
         <sequence>
            <nt>InstanceofExpr</nt>
            <ZeroOneOrMore>
               <or>
                  <literal type="Intersect">intersect</literal>
                  <literal type="Except">except</literal>
               </or>
               <nt>InstanceofExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>InstanceofExpr</lhs>
      <rhs>
         <sequence>
            <nt>TreatExpr</nt>
            <ZeroOrOne>
               <literal>instance</literal>
               <literal>of</literal>
               <nt>SequenceType</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>TreatExpr</lhs>
      <rhs>
         <sequence>
            <nt>CastableExpr</nt>
            <ZeroOrOne>
               <literal>treat</literal>
               <literal>as</literal>
               <nt>SequenceType</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>CastableExpr</lhs>
      <rhs>
         <sequence>
            <nt>CastExpr</nt>
            <ZeroOrOne>
               <literal>castable</literal>
               <literal>as</literal>
               <nt>SingleType</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>CastExpr</lhs>
      <rhs>
         <sequence>
            <nt>UnaryExpr</nt>
            <ZeroOrOne>
               <literal>cast</literal>
               <literal>as</literal>
               <nt>SingleType</nt>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>UnaryExpr</lhs>
      <rhs>
         <sequence>
            <or>
               <literal type="Substract">-</literal>
               <literal type="Add">+</literal>
            </or>
            <nt>ValueExpr</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ValueExpr</lhs>
      <rhs>
         <nt>SimpleMapExpr</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>GeneralComp</lhs>
      <or>
         <literal type="GeneralEquals">=</literal>
         <literal type="GeneralNotEqual">!=</literal>
         <literal type="GeneralLessThan">&lt;</literal>
         <literal type="GeneralLessThanOrEqual">&lt;=</literal>
         <literal type="GeneralGreaterThan">&gt;</literal>
         <literal type="GeneralGreaterThanOrEqual">&gt;=</literal>
      </or>
   </prod>
   <prod>
      <lhs>ValueComp</lhs>
      <or>
         <literal type="ValueEquals">eq</literal>
         <literal type="ValueNotEqual">ne</literal>
         <literal type="ValueLessThan">lt</literal>
         <literal type="ValueLessThanOrEqual">le</literal>
         <literal type="ValueGreaterThan">gt</literal>
         <literal type="ValueGreaterThanOrEqual">ge</literal>
      </or>
   </prod>
   <prod>
      <lhs>NodeComp</lhs>
      <or>
         <literal type="Is">is</literal>
         <literal type="Precedes">&lt;&lt;</literal>
         <literal type="IsPrecededBy">&gt;&gt;</literal>
      </or>
   </prod>
   <prod>
      <lhs>SimpleMapExpr</lhs>
      <rhs>
         <sequence>
            <nt>PathExpr</nt>
            <ZeroOneOrMore>
               <literal>!</literal>
               <nt>PathExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>PathExpr</lhs>
      <or>
         <unit>
            <literal>/</literal>
            <ZeroOrOne>
               <nt>RelativePathExpr</nt>
            </ZeroOrOne>
         </unit>
         <unit>
            <literal>//</literal>
            <nt>RelativePathExpr</nt>
         </unit>
         <nt>RelativePathExpr</nt>
      </or>
      <com>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink">xgc: leading-lone-slash</loc>
      </com>
   </prod>
   <prod>
      <lhs>RelativePathExpr</lhs>
      <rhs>
         <sequence>
            <nt>StepExpr</nt>
            <ZeroOneOrMore>
               <or>
                  <literal type="Step">/</literal>
                  <literal type="ZeroOneOrMoreStep">//</literal>
               </or>
               <nt>StepExpr</nt>
            </ZeroOneOrMore>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>StepExpr</lhs>
      <or>
         <nt>PostfixExpr</nt>
         <nt>AxisStep</nt>
      </or>
   </prod>
   <prod>
      <lhs>AxisStep</lhs>
      <rhs>
         <sequence>
            <or>
               <nt>ReverseStep</nt>
               <nt>ForwardStep</nt>
            </or>
            <nt>PredicateList</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ForwardStep</lhs>
      <or>
         <unit>
            <nt>ForwardAxis</nt>
            <nt>NodeTest</nt>
         </unit>
         <nt>AbbrevForwardStep</nt>
      </or>
   </prod>
   <prod>
      <lhs>ForwardAxis</lhs>
      <or>
         <unit>
            <literal>child</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>descendant</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>attribute</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>self</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>descendant-or-self</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>following-sibling</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>following</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>namespace</literal>
            <literal>::</literal>
         </unit>
      </or>
   </prod>
   <prod>
      <lhs>AbbrevForwardStep</lhs>
      <rhs>
         <sequence>
            <ZeroOrOne>
               <literal>@</literal>
            </ZeroOrOne>
            <nt>NodeTest</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ReverseStep</lhs>
      <or>
         <unit>
            <nt>ReverseAxis</nt>
            <nt>NodeTest</nt>
         </unit>
         <nt>AbbrevReverseStep</nt>
      </or>
   </prod>
   <prod>
      <lhs>ReverseAxis</lhs>
      <or>
         <unit>
            <literal>parent</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>ancestor</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>preceding-sibling</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>preceding</literal>
            <literal>::</literal>
         </unit>
         <unit>
            <literal>ancestor-or-self</literal>
            <literal>::</literal>
         </unit>
      </or>
   </prod>
   <prod>
      <lhs>AbbrevReverseStep</lhs>
      <rhs>
         <literal>..</literal>
      </rhs>
   </prod>
   <prod>
      <lhs>NodeTest</lhs>
      <or>
         <nt>KindTest</nt>
         <nt>NameTest</nt>
      </or>
   </prod>
   <prod>
      <lhs>NameTest</lhs>
      <or>
         <nt>EQName</nt>
         <nt>Wildcard</nt>
      </or>
   </prod>
   <prod>
      <lhs>Wildcard</lhs>
      <or>
         <literal type="Multiply">*</literal>
         <unit>
            <nt>NCName</nt>
            <literal>:</literal>
            <literal>*</literal>
         </unit>
         <unit>
            <literal>*</literal>
            <literal>:</literal>
            <nt>NCName</nt>
         </unit>
         <unit>
            <nt>BracedURILiteral</nt>
            <literal>*</literal>
         </unit>
      </or>
      <com>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink">ws: explicit</loc>
      </com>
   </prod>
   <prod>
      <lhs>PostfixExpr</lhs>
      <rhs>
         <sequence>
            <nt>PrimaryExpr</nt>
            <or>
               <nt>Predicate</nt>
               <nt>ArgumentList</nt>
            </or>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ArgumentList</lhs>
      <rhs>
         <sequence>
            <literal>(</literal>
            <ZeroOrOne>
               <nt>Argument</nt>
               <ZeroOneOrMore>
                  <literal>,</literal>
                  <nt>Argument</nt>
               </ZeroOneOrMore>
            </ZeroOrOne>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>PredicateList</lhs>
      <rhs>
         <ZeroOneOrMore>
            <nt>Predicate</nt>
         </ZeroOneOrMore>
      </rhs>
   </prod>
   <prod>
      <lhs>Predicate</lhs>
      <rhs>
         <sequence>
            <literal>[</literal>
            <nt>Expr</nt>
            <literal>]</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>PrimaryExpr</lhs>
      <or>
         <nt>Literal</nt>
         <nt>VarRef</nt>
         <nt>ParenthesizedExpr</nt>
         <nt>ContextItemExpr</nt>
         <nt>FunctionCall</nt>
         <nt>FunctionItemExpr</nt>
      </or>
   </prod>
   <prod>
      <lhs>Literal</lhs>
      <or>
         <nt>NumericLiteral</nt>
         <nt>StringLiteral</nt>
      </or>
   </prod>
   <prod>
      <lhs>NumericLiteral</lhs>
      <or>
         <nt>IntegerLiteral</nt>
         <nt>DecimalLiteral</nt>
         <nt>DoubleLiteral</nt>
      </or>
   </prod>
   <prod>
      <lhs>VarRef</lhs>
      <rhs>
         <sequence>
            <literal>$</literal>
            <nt>VarName</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>VarName</lhs>
      <rhs>
         <nt>EQName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>ParenthesizedExpr</lhs>
      <rhs>
         <sequence>
            <literal>(</literal>
            <ZeroOrOne>
               <nt>Expr</nt>
            </ZeroOrOne>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ContextItemExpr</lhs>
      <rhs>
         <literal>.</literal>
      </rhs>
   </prod>
   <prod>
      <lhs>FunctionCall</lhs>
      <rhs>
         <sequence>
            <nt>EQName</nt>
            <nt>ArgumentList</nt>
         </sequence>
      </rhs>
      <com>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink">xgc: reserved-function-names</loc>
      </com>
      <com>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink">gn: parens</loc>
      </com>
   </prod>
   <prod>
      <lhs>Argument</lhs>
      <or>
         <nt>ExprSingle</nt>
         <nt>ArgumentPlaceholder</nt>
      </or>
   </prod>
   <prod>
      <lhs>ArgumentPlaceholder</lhs>
      <rhs>
         <literal>?</literal>
      </rhs>
   </prod>
   <prod>
      <lhs>FunctionItemExpr</lhs>
      <or>
         <nt>NamedFunctionRef</nt>
         <nt>InlineFunctionExpr</nt>
      </or>
   </prod>
   <prod>
      <lhs>NamedFunctionRef</lhs>
      <rhs>
         <sequence>
            <nt>EQName</nt>
            <literal>#</literal>
            <nt>IntegerLiteral</nt>
         </sequence>
      </rhs>
      <com>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink">xgc: reserved-function-names</loc>
      </com>
   </prod>
   <prod>
      <lhs>InlineFunctionExpr</lhs>
      <rhs>
         <sequence>
            <literal>function</literal>
            <literal>(</literal>
            <ZeroOrOne>
               <nt>ParamList</nt>
            </ZeroOrOne>
            <literal>)</literal>
            <ZeroOrOne>
               <literal>as</literal>
               <nt>SequenceType</nt>
            </ZeroOrOne>
            <nt>FunctionBody</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>SingleType</lhs>
      <rhs>
         <sequence>
            <nt>SimpleTypeName</nt>
            <ZeroOrOne>
               <literal>?</literal>
            </ZeroOrOne>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>TypeDeclaration</lhs>
      <rhs>
         <sequence>
            <literal>as</literal>
            <nt>SequenceType</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>SequenceType</lhs>
      <or>
         <unit>
            <literal>empty-sequence</literal>
            <literal>(</literal>
            <literal>)</literal>
         </unit>
         <unit>
            <nt>ItemType</nt>
            <ZeroOrOne>
               <nt>OccurrenceIndicator</nt>
            </ZeroOrOne>
         </unit>
      </or>
   </prod>
   <prod>
      <lhs>OccurrenceIndicator</lhs>
      <or>
         <literal type="?">?</literal>
         <literal type="Multiply">*</literal>
         <literal type="Add">+</literal>
      </or>
      <com>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink">xgc: occurrence-indicators</loc>
      </com>
   </prod>
   <prod>
      <lhs>ItemType</lhs>
      <or>
         <nt>KindTest</nt>
         <unit>
            <literal>item</literal>
            <literal>(</literal>
            <literal>)</literal>
         </unit>
         <nt>FunctionTest</nt>
         <nt>AtomicOrUnionType</nt>
         <nt>ParenthesizedItemType</nt>
      </or>
   </prod>
   <prod>
      <lhs>AtomicOrUnionType</lhs>
      <rhs>
         <nt>EQName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>KindTest</lhs>
      <or>
         <nt>DocumentTest</nt>
         <nt>ElementTest</nt>
         <nt>AttributeTest</nt>
         <nt>SchemaElementTest</nt>
         <nt>SchemaAttributeTest</nt>
         <nt>PITest</nt>
         <nt>CommentTest</nt>
         <nt>TextTest</nt>
         <nt>NamespaceNodeTest</nt>
         <nt>AnyKindTest</nt>
      </or>
   </prod>
   <prod>
      <lhs>AnyKindTest</lhs>
      <rhs>
         <sequence>
            <literal>node</literal>
            <literal>(</literal>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>DocumentTest</lhs>
      <rhs>
         <sequence>
            <literal>document-node</literal>
            <literal>(</literal>
            <or>
               <nt>ElementTest</nt>
               <nt>SchemaElementTest</nt>
            </or>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>TextTest</lhs>
      <rhs>
         <sequence>
            <literal>text</literal>
            <literal>(</literal>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>CommentTest</lhs>
      <rhs>
         <sequence>
            <literal>comment</literal>
            <literal>(</literal>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>NamespaceNodeTest</lhs>
      <rhs>
         <sequence>
            <literal>namespace-node</literal>
            <literal>(</literal>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>PITest</lhs>
      <rhs>
         <sequence>
            <literal>processing-instruction</literal>
            <literal>(</literal>
            <or>
               <nt>NCName</nt>
               <nt>StringLiteral</nt>
            </or>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>AttributeTest</lhs>
      <rhs>
         <sequence>
            <literal>attribute</literal>
            <literal>(</literal>
            <ZeroOrOne>
               <nt>AttribNameOrWildcard</nt>
               <ZeroOrOne>
                  <literal>,</literal>
                  <nt>TypeName</nt>
               </ZeroOrOne>
            </ZeroOrOne>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>AttribNameOrWildcard</lhs>
      <or>
         <nt>AttributeName</nt>
         <literal type="Multiply">*</literal>
      </or>
   </prod>
   <prod>
      <lhs>SchemaAttributeTest</lhs>
      <rhs>
         <sequence>
            <literal>schema-attribute</literal>
            <literal>(</literal>
            <nt>AttributeDeclaration</nt>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>AttributeDeclaration</lhs>
      <rhs>
         <nt>AttributeName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>ElementTest</lhs>
      <rhs>
         <sequence>
            <literal>element</literal>
            <literal>(</literal>
            <ZeroOrOne>
               <nt>ElementNameOrWildcard</nt>
               <ZeroOrOne>
                  <literal>,</literal>
                  <nt>TypeName</nt>
                  <ZeroOrOne>
                     <literal>?</literal>
                  </ZeroOrOne>
               </ZeroOrOne>
            </ZeroOrOne>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ElementNameOrWildcard</lhs>
      <or>
         <nt>ElementName</nt>
         <literal type="Multiply">*</literal>
      </or>
   </prod>
   <prod>
      <lhs>SchemaElementTest</lhs>
      <rhs>
         <sequence>
            <literal>schema-element</literal>
            <literal>(</literal>
            <nt>ElementDeclaration</nt>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ElementDeclaration</lhs>
      <rhs>
         <nt>ElementName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>AttributeName</lhs>
      <rhs>
         <nt>EQName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>ElementName</lhs>
      <rhs>
         <nt>EQName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>SimpleTypeName</lhs>
      <rhs>
         <nt>TypeName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>TypeName</lhs>
      <rhs>
         <nt>EQName</nt>
      </rhs>
   </prod>
   <prod>
      <lhs>FunctionTest</lhs>
      <or>
         <nt>AnyFunctionTest</nt>
         <nt>TypedFunctionTest</nt>
      </or>
   </prod>
   <prod>
      <lhs>AnyFunctionTest</lhs>
      <rhs>
         <sequence>
            <literal>function</literal>
            <literal>(</literal>
            <literal>*</literal>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>TypedFunctionTest</lhs>
      <rhs>
         <sequence>
            <literal>function</literal>
            <literal>(</literal>
            <ZeroOrOne>
               <nt>SequenceType</nt>
               <ZeroOneOrMore>
                  <literal>,</literal>
                  <nt>SequenceType</nt>
               </ZeroOneOrMore>
            </ZeroOrOne>
            <literal>)</literal>
            <literal>as</literal>
            <nt>SequenceType</nt>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>ParenthesizedItemType</lhs>
      <rhs>
         <sequence>
            <literal>(</literal>
            <nt>ItemType</nt>
            <literal>)</literal>
         </sequence>
      </rhs>
   </prod>
   <prod>
      <lhs>EQName</lhs>
      <rhs>
      <or>
         <nt>QName</nt>
         <nt>URIQualifiedName</nt>
      </or>
   </rhs>
   </prod>
</grammar>



   <test>
       <rhs><nt>VarRef</nt></rhs>

      <testcase text="$x"/>-->
      <!--<testcase text="$x * 100 - $y * 10  - $z - $a * $b * $c ??????????"/>-->
      <!--<testcase text="(  ) * 30" This example shows a problem with expression '()' currently. Need decide how seq of expr processed. 5 March 2023 /> -->
      <!--<testcase text="if 1 then $x * ($y + $z) else 999"/>-->
   </test>

</ebnf>
