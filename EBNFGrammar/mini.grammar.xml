<ebnf>
	<grammar>
		<prod>
		    <lhs>lowercase_identifier</lhs>
		    <rhs>
		    	<token regexp="^[a-z]+"/>
		    </rhs>
		</prod>
		<prod>
		    <lhs>NameStartChar</lhs>
		    <rhs whitespace="explicit">
		    	<token regexp="^[A-Z]|^_|^[a-z]|^[&#xC0;-&#xD6;]|^[&#xD8;-&#xF6;]|^[&#xF8;-&#x2FF;]|^[&#x370;-&#x37D;]|^[&#x37F;-&#x1FFF;]|^[&#x200C;-&#x200D;]|^[&#x2070;-&#x218F;]|^[&#x2C00;-&#x2FEF;]|^[&#x3001;-&#xD7FF;]|^[&#xF900;-&#xFDCF;]|^[&#xFDF0;-&#xFFFD;]|^[&#x10000;-&#xEFFFF;]" />
		    </rhs>
		</prod>
		<prod>
		    <lhs>AdditionalNameChar</lhs>
		    <rhs whitespace="explicit">
		    	<token regexp="^-|^\.|^[0-9]|^&#xB7;|^[&#x0300;-&#x036F;]|^[&#x203F;-&#x2040;]"/>
		    </rhs>
		</prod>
		<prod>
		    <lhs>Char</lhs>
		    <rhs>
		    	<token regexp="^&#x9;|^&#xA;|^&#xD;|^[&#x20;-&#xD7FF;]|^[&#xE000;-&#xFFFD;]|^[&#x10000;-&#x10FFFF;]"/>
		    </rhs>
		</prod>
		<prod>
		    <lhs>CharCode</lhs>
		    <rhs>
		    	<token regexp="^#x[0-9a-fA-F]+"/>
		    </rhs>
		</prod>
		<prod>
		    <lhs>S</lhs>
		    <rhs>
		    	<token regexp="^&#x9;|^&#xA;|^&#xD;|^&#x20;" />
		    	        /* #x9 is TAB    */
				        /* #xA is LF     */
				        /* #xD is CR     */
				        /* #x20 is SPACE */
		    </rhs>
		</prod>
		<prod>
		    <lhs>NonNegativeNumber</lhs>
		    <rhs>
		    	<token regexp="^[0-9]+"/>
		    </rhs>
		</prod>
		<prod>
			<lhs>OtherNameChar</lhs>
		    <rhs>  
	       	    <or>
	       	  	<nt>NameStartChar</nt> 
		       	<nt>AdditionalNameChar</nt>
		       </or>
		    </rhs>
		</prod>
		<prod>
			<lhs>Name</lhs>
		    <rhs mode="scan">
		    	<sequence>
		       	  	<nt>NameStartChar</nt> 
			       	<ZeroOneOrMore>
			       	   <nt>OtherNameChar</nt>  
			       	</ZeroOneOrMore>
		       </sequence>
		    </rhs>
		</prod>
	    <prod>
		    <lhs>Expr</lhs>
		    <rhs>
		      	<or>
		        	<nt>IfExpr</nt>
		        	<nt>AdditiveExpr</nt>
		     	</or>
	    	</rhs>
	    </prod>
      	<prod>
		    <lhs>IfExpr</lhs>  
	      	<rhs>
	      		<sequence>
					<nt>IfPart</nt>
					<nt>ThenPart</nt>
					<nt>ElsePart</nt>
				</sequence>
	      	</rhs>
		</prod>
		<prod>
		    <lhs>IfPart</lhs>  
	      	<rhs>
	      		<sequence>
		      		<literal>if</literal>
					<nt>Expr</nt>
				</sequence>
	      	</rhs>
		</prod>
		<prod>
		    <lhs>ThenPart</lhs>  
	      	<rhs>
	      		<sequence>
		      		<literal>then</literal>
					<nt>Expr</nt>
				</sequence>
	      	</rhs>
		</prod>
		<prod>
		    <lhs>ElsePart</lhs>  
	      	<rhs>
	      		<sequence>
		      		<literal>else</literal>
					<nt>Expr</nt>
				</sequence>
	      	</rhs>
		</prod>
		<prod>
		    <lhs>AdditiveExpr</lhs>  
	      	<rhs>
	      		<sequence>
					<nt>MultiplicativeExpr</nt>
					<ZeroOneOrMore OneOrMore="AdditiveTail" type="AdditiveTerm">
						<or type="AdditiveOperator">
			               <literal type="Add">+</literal>
			               <literal type="Subtract">-</literal>
				     	</or>
						<nt>MultiplicativeExpr</nt>
					</ZeroOneOrMore>
				</sequence>
	      	</rhs>
		</prod>

	   <prod>
	      <lhs>MultiplicativeExpr</lhs>
	      <rhs>
	      	<sequence>
		         <nt>PrimaryExpr</nt>      	<!-- should/will be unionExpr in full syntax -->
		         <ZeroOneOrMore OneOrMore="MultiplicativeTail" type="MultiplicativeTerm">
		        	<or type="MultiplicativeOperator">
		               <literal type="Multiply">*</literal>
		               <literal type="Divide">div</literal>
		               <literal type="IntegerDivide">idiv</literal>
		               <literal type="Modulo">mod</literal>
		            </or>
		            <nt>PrimaryExpr</nt> 	<!-- should be UnionExpr -->
		         </ZeroOneOrMore>
		     </sequence>
	      </rhs>
	   </prod>

	    <prod>
		    <lhs>PrimaryExpr</lhs>
		    <rhs>
		      	<or>
		        	<nt>VarRef</nt>
		        	<nt>Literal</nt>
         			<nt>ParenthesizedExpr</nt>
		     	</or>
	    	</rhs>
	    </prod>
		<prod>
		    <lhs>VarRef</lhs>  
	      	<rhs>
	      		<sequence>
		      		<literal>$</literal>
					<nt>Name</nt>
				</sequence>
	      	</rhs>
		</prod>
		<prod>
		    <lhs>Literal</lhs>  
	      	<rhs mode="scan">
				<nt>NonNegativeNumber</nt>
	      	</rhs>
		</prod>
		<prod>
	      <lhs>ParenthesizedExpr</lhs>
	      <rhs>
	      	<sequence>
		         <literal>(</literal>
		        <ZeroOrOne>
		            <nt>Expr</nt>
		        </ZeroOrOne>
		        <literal>)</literal>
	      	</sequence>
	      </rhs>
	   </prod>

   <prod >
      <lhs>UnionExpr</lhs>
      <rhs>
         <nt>IntersectExceptExpr</nt>
         <ZeroOneOrMore>
            <or>
               <literal>union</literal>
               <literal>|</literal>
            </or>
            <nt>IntersectExceptExpr</nt>
         </ZeroOneOrMore>
      </rhs>
   </prod>
   <prod>
      <lhs>IntersectExceptExpr</lhs>
      <rhs>
      	<sequence>
	         <nt>InstanceofExpr</nt>
	         <ZeroOneOrMore>
	            <or>
	               <literal>intersect</literal>
	               <literal>except</literal>
	            </or>
	            <nt>InstanceofExpr</nt>  <!-- should be InstanceofExpr -->
	         </ZeroOneOrMore>
     	</sequence>
      </rhs>
   </prod>

	</grammar>

	<test>
	    <rhs><nt>Expr</nt></rhs>
		<!--<testcase text="$x * 100 - $y * 10  - $z - $a * $b * $c ??????????"/>-->
		<!--<testcase text="(  ) * 30"  This example shows a problem with expression '()' currently. Need decide how seq of expr processed. 5 March 2023--> /> 
		<testcase text="if 1 then $x * ($y + $z) else 999"/>
	</test>

</ebnf>
